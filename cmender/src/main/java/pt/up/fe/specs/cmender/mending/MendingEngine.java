package pt.up.fe.specs.cmender.mending;

import com.fasterxml.jackson.databind.ObjectMapper;
import pt.up.fe.specs.cmender.CMenderInvocation;
import pt.up.fe.specs.cmender.cli.CliReporting;
import pt.up.fe.specs.cmender.data.CMenderDataManager;
import pt.up.fe.specs.cmender.data.MendingDirData;
import pt.up.fe.specs.cmender.diag.DiagExporter;
import pt.up.fe.specs.cmender.diag.DiagExporterDeserializationException;
import pt.up.fe.specs.cmender.diag.DiagExporterException;
import pt.up.fe.specs.cmender.diag.DiagExporterInvocation;
import pt.up.fe.specs.cmender.diag.DiagExporterResult;
import pt.up.fe.specs.cmender.diag.Diagnostic;
import pt.up.fe.specs.cmender.logging.Logging;
import pt.up.fe.specs.cmender.mending.analysis.AnalysisFactory;
import pt.up.fe.specs.cmender.mending.analysis.DiagnosticAnalysis;
import pt.up.fe.specs.cmender.mending.handler.HandlerFactory;
import pt.up.fe.specs.cmender.mending.handler.MendingHandler;
import pt.up.fe.specs.cmender.utils.SizeBundle;
import pt.up.fe.specs.cmender.utils.TimeBundle;
import pt.up.fe.specs.cmender.utils.TimeMeasure;
import pt.up.fe.specs.cmender.utils.TimedResult;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class MendingEngine {
    private static final String MENDING_DISCLAIMER_IN_SOURCE = """
            /* Source File Copy
             * This file was automatically mended by the CMender tool.
             * A header file with the necessary mends (symbol declarations) is included.
             * The mending process is not guaranteed to be correct, nor to preserve the original semantics.
             * The user should review the changes and test the code if needed.
             */""";

    private static final String MENDING_DISCLAIMER_IN_MENDFILE = """
            /* Mendfile
             * This header file  was automatically generated by the CMender tool.
             * It contains the necessary mends to fix the errors found by the diag-exporter tool.
             */""";

    private final DiagExporter diagExporter;

    private final CMenderInvocation menderInvocation;

    private final Map<String, Integer> unknownDiagsFrequency;

    private final DiagnosticAnalysis diagnosticAnalysis;

    private final MendingHandler mendingHandler;

    public MendingEngine(CMenderInvocation menderInvocation) {
        diagExporter = new DiagExporter(menderInvocation.getDiagExporterPath());
        this.menderInvocation = menderInvocation;
        this.unknownDiagsFrequency = new ConcurrentHashMap<>(); // TODO is this the best choice?
        this.diagnosticAnalysis = AnalysisFactory.createAnalysis(menderInvocation.getAnalysis());
        this.mendingHandler = HandlerFactory.createHandler(menderInvocation.getHandler());
    }

    public MendingEngineBundle execute() {
        var files = getExistingValidFiles(getAbsolutePaths(menderInvocation.getFiles()));

        if (files.isEmpty()) {
            CliReporting.warning("no valid input files provided, exiting");
            Logging.FILE_LOGGER.warn("no valid input files provided, exiting");
            return null;
        }

        // TODO currently we have one diag-exporter invocation per file
        //   We should support multiple files in a single invocation
        //   It involves changing the logic the engine and exporting the mending dir
        // TODO how should multithreading be handled? (e.g., one thread per batch of files etc.)

        SourceResult[] sourceResults = menderInvocation.isReportPerSource() ? new SourceResult[files.size()] : null;

        MendingDirData[] mendingDirDatas = new MendingDirData[files.size()];

        AtomicLong successCountAtomic = new AtomicLong();
        AtomicLong exceptionCountAtomic = new AtomicLong();
        // For single-threaded mode (avoid the overhead of atomic operations when we are just using one thread)) TODO maybe we should even not create the AtomicLongs in single-threaded mode
        long successCount = 0;
        long exceptionCount = 0;

        // TODO validate number of threads

        boolean singleThreaded = menderInvocation.getThreads() == 1;

        // todo add warning if files == 1 and threads > 1

        if (singleThreaded) {
            CliReporting.info("running in single-thread mode");

            for (int i = 0; i < files.size(); i++) {
                var file = files.get(i);
                System.out.println(file);

                var bundle = mend(file);

                if (bundle.mendingDirData() == null) {
                    CliReporting.warning("could not create mending dir for file: '%s'", file);
                    Logging.FILE_LOGGER.warn("could not create mending dir for file: '{}'", file);

                    continue;
                }

                successCount += bundle.sourceResult().success()? 1 : 0;
                exceptionCount += bundle.sourceResult().fatalException() != null? 1 : 0;

                if (menderInvocation.isReportPerSource()) {
                    writeSourceReport(bundle.mendingDirData(), bundle.sourceResult());
                } else {
                    assert sourceResults != null;
                    sourceResults[i] = bundle.sourceResult();
                }

                mendingDirDatas[i] = bundle.mendingDirData();
            }
        } else {
            CliReporting.info("running in multi-thread mode with %d threads", menderInvocation.getThreads());

            ExecutorService executorService = Executors.newFixedThreadPool(menderInvocation.getThreads());

            for (int i = 0; i < files.size(); i++) {
                var file = files.get(i);
                System.out.println(file);
                int finalI = i;

                executorService.submit(() -> {
                    var bundle = mend(file);

                    if (bundle.sourceResult().success()) {
                        successCountAtomic.incrementAndGet();
                    }

                    if (bundle.sourceResult().fatalException() != null) {
                        exceptionCountAtomic.incrementAndGet();
                    }

                    if (menderInvocation.isReportPerSource()) {
                        writeSourceReport(bundle.mendingDirData(), bundle.sourceResult());
                    } else {
                        assert sourceResults != null;
                        sourceResults[finalI] = bundle.sourceResult();
                    }

                    mendingDirDatas[finalI] = bundle.mendingDirData();
                });
            }

            executorService.shutdown();

            try {
                if (!executorService.awaitTermination(10, TimeUnit.MINUTES)) {
                    executorService.shutdownNow(); // Force shutdown if not finished in 10 minutes
                }
            } catch (InterruptedException e) {
                executorService.shutdownNow();
                Thread.currentThread().interrupt(); // Preserve interrupt status
            }
        }

        // Useful for when the mending dir could not have been produced

        var nullMendingDirs = new ArrayList<String>();

        for (int i = 0; i < files.size(); i++) {
            var file = files.get(i);
            var mendingDirData = mendingDirDatas[i];

            if (mendingDirData == null) {
                nullMendingDirs.add(file);
            }
        }

        /*if (sourceResults.size() != files.size()) {
            CliReporting.warning("not all files were processed, exiting");
            Logging.FILE_LOGGER.warn("not all files were processed, exiting");
        }*/

        List<SourceResult> sourceResultsList;
        if (menderInvocation.isReportPerSource()) {
            sourceResultsList = new ArrayList<>();
        } else {
            assert sourceResults != null;
            sourceResultsList = Arrays.stream(sourceResults).toList();
        }

        /*var successCount = (int) sourceResultsList.stream().filter(SourceResult::success).count();
        var unsuccessfulCount = files.size() - successCount;
        var exceptionCount = (int) sourceResultsList.stream().filter(result -> result.fatalException() != null).count();*/


        if (!singleThreaded) {
            successCount = successCountAtomic.get();
            exceptionCount = exceptionCountAtomic.get();
        }

        var unsuccessfulCount = files.size() - successCount;

        var cmenderReport = CMenderReport.builder()
                .invocation(menderInvocation)
                .totalFiles(files.size())

                .successCount(successCount)
                .unsuccessfulCount(unsuccessfulCount)
                .fatalExceptionCount(exceptionCount)

                .successRatio((double) successCount / files.size())
                .unsuccessfulRatio((double) unsuccessfulCount / files.size())
                .fatalExceptionRatio((double) exceptionCount / files.size())
                .fatalExceptionOverUnsuccessfulRatio(unsuccessfulCount == 0? 0.0 : (double) exceptionCount / unsuccessfulCount)

                .unknownDiagsFrequency(unknownDiagsFrequency)
                .uniqueUnknownDiagsCount(unknownDiagsFrequency.size())
                .nullMendingDirs(nullMendingDirs)
                .sourceResults(sourceResultsList)
                .build();

        return new MendingEngineBundle(cmenderReport, Arrays.stream(mendingDirDatas).toList());
    }

    private MendBundle mend(String sourceFile) {
        var mendingDirData = CMenderDataManager.createMendingDir(sourceFile, menderInvocation.isNoDisclaimer()? null : MENDING_DISCLAIMER_IN_SOURCE,
                menderInvocation.getMendfileFilename(), menderInvocation.getDiagsOutputFilename(), menderInvocation.getSourceReportFilename());
        System.out.println(mendingDirData);

        if (mendingDirData == null) {
            CliReporting.error("could not create mending dir for file: '%s'", sourceFile);
            //continue;

            return new MendBundle(SourceResult.builder()
                    .success(false)
                    .fatalException(new MendingEngineFatalException(MendingEngineFatalException.FatalType.MENDING_DIR_CREATION, "could not create mending dir", 0, null))
                    .build(), null);
            //throw new RuntimeException("mendingDirData is null");
        }

        String sourceFileCopy = mendingDirData.sourceFileCopyPath();

        var mendingTable = new MendingTable();
        var maxTotalIterations = menderInvocation.getMaxTotalIterations();

        // TODO think about stopping criteria (to avoid infinite loops)
        //  1) max number of total iterations (to avoid infinite loops) -> how do we decide the value? because it depends on the number of
        //      diagnostics. if we select to process one diagnostic at a time, we require a higher number of iterations.
        //  2) max number of successive mending failures (to avoid infinite loops) -> by failure we mean that the mend was not helpful (what do we consider helpful?);
        //      perhaps have methods that hash the state of the MendingTable and compare them between consecutive iterations or look at the variation through time (e.g., derivative)
        //  3) total time -> maybe not the best approach, because the time can vary a lot depending on the number of diagnostics and the complexity of the mends.
        //      but can also be a more conservative approach (and we can do load tests to find a good estimate.

        var timedSourceResult = TimeMeasure.measureElapsed(() -> {
            var success = false;
            var finished = false;
            var detectedLoop = false;
            var currentIteration = 0L;

            var diagExporterTotalTime = 0L;
            // var mendingTotalTime = 0L;
            // var mendfileWritingTotalTime = 0L;

            List<DiagnosticShortInfo> unknownDiags = new ArrayList<>();

            List<MendingIterationResult> iterationResults = new ArrayList<>();

            while (!finished && currentIteration++ < maxTotalIterations && !detectedLoop) {
                MendingIterationResult mendingIterationResult = null;
                try {
                    mendingIterationResult = mendingIteration(mendingDirData, currentIteration, mendingTable);
                } catch (MendingEngineFatalException e) {

                    return SourceResult.builder()
                            .success(false)
                            .fileSize(SizeBundle.fromBytes(mendingTable.fileSize()))
                            .fatalException(e)
                            .iterationCount(currentIteration)
                            .unknownDiags(mendingTable.unknownDiags())
                            .mendingIterations(iterationResults)
                            .diagExporterTotalTime(TimeBundle.fromNanos(diagExporterTotalTime))
                            .build();
                }

                diagExporterTotalTime += mendingIterationResult.diagExporterTime().nanos();

                success = mendingIterationResult.terminationStatus().success();
                finished = success || mendingIterationResult.terminationStatus().finishedPrematurely(menderInvocation);

                for (var unknownDiag : mendingTable.unknownDiags()) {
                    unknownDiagsFrequency.put(unknownDiag.id(), unknownDiagsFrequency.getOrDefault(unknownDiag.id(), 0) + 1);
                    unknownDiags.add(unknownDiag);
                }

                iterationResults.add(mendingIterationResult);

                detectedLoop = mendingIterationResult.terminationStatus().terminationType() == MendingTerminationStatus.TerminationType.DETECTED_CYCLE;
            }

            return SourceResult.builder()
                    .success(success)
                    .fileSize(SizeBundle.fromBytes(mendingTable.fileSize()))
                    .iterationCount(currentIteration)
                    .diagExporterTotalTime(TimeBundle.fromNanos(diagExporterTotalTime))
                    .unknownDiags(mendingTable.unknownDiags())
                    .mendingIterations(iterationResults)
                    .build();
        });

        var result = timedSourceResult.result();

        CliReporting.info("Source file '%s' was %s", sourceFileCopy, result.success() ? "successfully mended" : "unsuccessfully mended");
        Logging.FILE_LOGGER.info("source file '{}' was {}", sourceFileCopy, result.success() ? "successfully mended" : "unsuccessfully mended");

        var totalTime = timedSourceResult.elapsedTime();

        long diagExporterTotalTime = result.diagExporterTotalTime().nanos();

        return new MendBundle(result.toBuilder()
                .sourceFile(sourceFile)
                .completionStatusEstimate(result.success() ? 1.0 : // if there is an error in the first invocation, we don't have a completion status nor a mendfile size
                        (result.mendingIterations().isEmpty() ? 0.0 : result.mendingIterations().getLast().terminationStatus().fileProgress()))
                .mendfileSize(result.mendingIterations().isEmpty()? SizeBundle.fromBytes(0) : result.mendingIterations().getLast().mendfileSize())                .totalTime(TimeBundle.fromNanos(totalTime))
                .diagExporterTotalTime(TimeBundle.fromNanos(diagExporterTotalTime, totalTime))
                .otherTotalTime(TimeBundle.fromNanos(totalTime - diagExporterTotalTime, totalTime))
                .build(), mendingDirData);
    }

        // we don't calculate this based on the line of the last successful iteration
        //    just the line of the last iteration that might have had an unhandled error.

        // This is because from the last successful line to the next line with an error to be handled
        //    we have many lines of code that are not being processed (and can be correct)

        // Still it's possible that we might go back to a previous line that was already processed
        //     making this metric just an estimate of "how much of the code was processed and likely to be correct"

        // TODO Maybe we can mix this metric with the number of missing diagnostics (which also is an estimate because its not
        //     guaranteed that the diagnostics will decrease with each iteration, and not cycle a bit)
        // TODO maybe create metric of the cyclicity of the line of the first diagnostic


    private MendingIterationResult mendingIteration(MendingDirData mendingDirData, long currentIteration,
                                                    MendingTable mendingTable) {
        var timedResult = TimeMeasure.measureElapsed(() -> {
            // long mendfileWritingTime = 0;

            TimedResult<DiagExporterResult> diagExporterTimedResult = callDiagExporter(mendingDirData, currentIteration);
            DiagExporterResult diagExporterResult = diagExporterTimedResult.result();

            mendingTable.setFileSize(diagExporterResult.sourceResults().getFirst().size());

            var diagExporterSourceResult = diagExporterResult.sourceResults().getFirst();

            try {
                // TODO we can also have a flag to finish only if there are no diagnostics (e.g., include warnings)
                // TODO maybe process warnings (?) this might change even more the original code (for the worse) because it might
                // have been present on the original code

                // TODO for now we don't have a need to to process notes, but they might be useful in the future

                var termination = diagnosticAnalysis.checkTermination(diagExporterSourceResult, mendingTable);
                List<Integer> selectedDiagIdxs = new ArrayList<>();
                DiagnosticMendResult mendResult = null;

                // mendfile size is calculated before the mend is applied (so it is from the previous iteration or the initial size (0))
                SizeBundle mendfileSize = SizeBundle.fromBytes(Paths.get(mendingDirData.mendfilePath()).toFile().length());

                for (var unknownDiag : termination.unknownDiags()) {
                    mendingTable.addUnknownDiag(
                            DiagnosticShortInfo.from(diagExporterSourceResult.diags().get(unknownDiag)));
                }

                if (!termination.success() && !termination.finishedPrematurely(menderInvocation)) {
                    selectedDiagIdxs = diagnosticAnalysis.selectDiagnostics(diagExporterSourceResult, mendingTable);
                    var selectedDiags = new ArrayList<Diagnostic>();

                    for (var idx : selectedDiagIdxs) {
                        selectedDiags.add(diagExporterSourceResult.diags().get(idx));
                    }

                    mendResult = mendingHandler.mend(selectedDiags, mendingTable, mendingDirData);

                    // avoid writing the mendfile if no mends were applied (avoid unnecessary file writes)
                    // e.g., if we have an unknown diagnostic we don't want to write a mendfile because we skip the mending
                    // iteration
                    // todo enforce this. when errors are due to missing headers, this always repeat the same mendfile
                    if (/*appliedMend || */!menderInvocation.isCreateMendfileOnlyOnAlterations()) {
                        /*mendfileWritingTime = */
                        writeMendfile(mendingTable, mendingDirData, currentIteration);
                    }

                    // mendfileSize = SizeBundle.fromBytes(Paths.get(mendingDirData.mendfilePath()).toFile().length());
                }

                System.out.println();

                return MendingIterationResult.builder()
                        .terminationStatus(termination)
                        .selectedDiagnostics(selectedDiagIdxs)
                        .errorCount(diagExporterSourceResult.errorCount())
                        .fatalCount(diagExporterSourceResult.fatalCount())
                        .mendResult(mendResult)
                        .mendfileSize(mendfileSize)
                        .diagExporterTime(TimeBundle.fromNanos(diagExporterTimedResult.elapsedTime()))
                        .build();
            } catch (Exception e) { // for unchecked exceptions
                e.printStackTrace();
                // TODO maybe we should only log here the exception's message and not the palce that generates the exception (i.e on the handlers) because then it is logged two times
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error(e.getMessage());
                CliReporting.error("could not process diagnostics from file: '%s'", mendingDirData.diagsFilePath());
                throw new MendingEngineFatalException(MendingEngineFatalException.FatalType.MENDING, "could not process diagnostics", currentIteration, e);
            }
        });

        var result = timedResult.result();

        var totalTime = timedResult.elapsedTime();
        var diagExporterTime = result.diagExporterTime().nanos();

        return result.toBuilder()
                .totalTime(TimeBundle.fromNanos(totalTime))
                .diagExporterTime(TimeBundle.fromNanos(diagExporterTime, totalTime))
                .otherTime(TimeBundle.fromNanos(totalTime - diagExporterTime, totalTime))
                .build();
    }

    private TimedResult<DiagExporterResult> callDiagExporter(MendingDirData mendingDirData, long iteration) {
        return TimeMeasure.measureElapsed(() -> {
            DiagExporterResult result = null;
            try {
                // TODO we dont need to always create the invocation since its arguments dont generally change between iterations of the same file
                result = diagExporter.run(
                        DiagExporterInvocation
                                .builder()
                                .includePaths(List.of(mendingDirData.includePath()))
                                .files(List.of(mendingDirData.sourceFileCopyPath()))
                                .outputFilepath(mendingDirData.diagsFilePath())
                                .build());

                // copy the diags output file for each iteration
                if (menderInvocation.isCreateDiagsOutputCopyPerIteration()) {
                    var filenameNoExt = removeExtension(menderInvocation.getDiagsOutputFilename());
                    var copyPath = Paths.get(mendingDirData.diagsDirPath(), filenameNoExt + "_" + iteration + ".json").toFile();
                    Files.copy(Paths.get(mendingDirData.diagsFilePath()), copyPath.toPath());
                }
                return result;
            } catch (DiagExporterException e) {
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error(e.getMessage());
                CliReporting.error("could not export Clang diagnostics from file: '%s'", mendingDirData.sourceFileCopyPath());
                throw new MendingEngineFatalException(MendingEngineFatalException.FatalType.DIAG_EXPORTER, "could not export Clang diagnostics", iteration, e);
            } catch (IOException e) {
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error(e.getMessage());
                CliReporting.error("could not copy diags output file for iteration %d", iteration);
                return result;
                // TODO the exception is not fatal (we dont use the copies), but we should log it and save in the report
                //throw new MendingEngineFatalException(MendingEngineFatalException.FatalType.DIAG_EXPORTER, "could not copy diags output file", iteration, e);
            } catch (DiagExporterDeserializationException e) {
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error(e.getMessage());
                CliReporting.error("could not deserialize Clang diagnostics from file: '%s'", mendingDirData.diagsFilePath());
                throw new MendingEngineFatalException(MendingEngineFatalException.FatalType.DIAG_EXPORTER_RESULT_DESERIALIZATION, "could not deserialize Clang diagnostics", iteration, e);
            }
        });
    }

    private long writeMendfile(MendingTable table, MendingDirData mendingDirData, long currentIteration) {
        return TimeMeasure.measureElapsed(() -> {
            try {
                //var mendfile = Paths.get(mendingDirData.includePath(), MENDFILE_FILENAME).toFile();
                var mendfile = Paths.get(mendingDirData.mendfilePath()).toFile();

                var writer = new BufferedWriter(new FileWriter(mendfile));

                if (!menderInvocation.isNoDisclaimer()) {
                    writer.write(MENDING_DISCLAIMER_IN_MENDFILE);
                    writer.newLine();
                }

                table.writeSymbolDecls(writer);

                if (menderInvocation.isCreateMendfileCopyPerIteration()) {
                    var mendfileNameNoExt = removeExtension(menderInvocation.getMendfileFilename());
                    var mendfileCopyPath = Paths.get(mendingDirData.mendfileCopiesDirPath(), mendfileNameNoExt + "_" + currentIteration + ".h").toFile();

                    Files.copy(mendfile.toPath(), mendfileCopyPath.toPath());

                    // TODO we shouldnt need to get the canonical path here. refactor when creating the CMender data path and mendingdirs
                    mendingDirData.mendfileCopyPaths().add(mendfileCopyPath.getCanonicalPath());
                }
            } catch (IOException e) {
                // TODO differentiaite between file writing errors and file copying errors
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error("could not write mendfile or copy: '%s'", mendingDirData.mendfilePath());
                throw new MendingEngineFatalException(
                        MendingEngineFatalException.FatalType.MENDFILE_WRITER,
                            String.format("could not write mendfile or copy: '%s'", mendingDirData.mendfilePath()), currentIteration, e);
            }
        });
    }

    private long writeSourceReport(MendingDirData mendingDirData, SourceResult sourceResult) {
        return TimeMeasure.measureElapsed(() -> {
            try {
                ObjectMapper mapper = new ObjectMapper();
                mapper.writerWithDefaultPrettyPrinter().writeValue(new File(mendingDirData.sourceReportPath()), sourceResult);
            } catch (IOException e) {
                Logging.FILE_LOGGER.error(e.getMessage(), e);
                CliReporting.error("could not write source report: '%s'", mendingDirData.sourceReportPath());
                throw new MendingEngineFatalException(MendingEngineFatalException.FatalType.SOURCE_RESULT_WRITER, String.format("could not write source report: '%s'", mendingDirData.sourceReportPath()), sourceResult.iterationCount(), e);
            }
        });
    }

    private List<String> getAbsolutePaths(List<String> files) {
        var absolutePaths = new HashSet<String>();

        for (var file : files) {
            try {
                absolutePaths.add(Paths.get(file).toAbsolutePath().toString());
            } catch (InvalidPathException e) {
                CliReporting.error("invalid input file path: '%s'", file);
                Logging.FILE_LOGGER.error("invalid input file path: '{}'", file);
            }
        }

        return new ArrayList<>(absolutePaths);
    }

    private List<String> getExistingValidFiles(List<String> paths) {
        var existingValidFiles = new ArrayList<String>();

        for (var path : paths) {
            var file = new File(path);

            if (!file.exists()) {
                CliReporting.error("file does not exist: '%s'", file);
                Logging.FILE_LOGGER.error("file does not exist: '{}'", file);
            } else if (!file.isFile()) {
                CliReporting.error("not a file: '%s'", file);
                Logging.FILE_LOGGER.error("not a file: '{}'", file);
            } else if (!file.canRead()) {
                CliReporting.error("cannot read file: '%s'", file);
                Logging.FILE_LOGGER.error("cannot read file: '{}'", file);
            } else {
                try {
                    existingValidFiles.add(file.getCanonicalPath());
                } catch (IOException e) {
                    CliReporting.error("failed to get canonical path for file: '%s'", file);
                    Logging.FILE_LOGGER.error("failed to get canonical path for file: '{}'", file);
                }
            }
        }

        return existingValidFiles;
    }

    private static String removeExtension(String filename) {
        int lastDot = filename.lastIndexOf('.');
        return lastDot == -1 ? filename : filename.substring(0, lastDot);
    }
}
